---
layout: post
title: go语言
description: coding
category: blog
---

最近在做asr项目，先是十五分钟精通cuda，然后又十五分钟精通go。然后项目就要上线了，不挂的话，我觉得应该去买个彩票了。用go实现了个websocket的server，代码参考[gorilla/websocket](https://github.com/gorilla/websocket)，使用下来对go的整体感觉就是python的语法，c的性能，然后是比python还变态的规范要求。虽然没有python的缩进要求，但go对于代码规范的要求简直了，比如定义了不用的变量就报错，某些特性对大小写的强制要求，还有注释都是会被编译的，要是拷贝别人代码少了一行注释可能都无法正常使用。但是，整体来说，简单使用之后还是对go好感度倍增。为啥？一个go build命令就可以编译，一个go get就可以拉包，简直就是懒癌救星。话不多说，以下为一个go调用c的函数，然后c里调用go的回调函数的示例
  package main

  /*
  #include <stdio.h>
  #include "load_so.h"

  extern int callOnMeGo(int,  char *);

  #cgo LDFLAGS: -ldl
  */
  import "C"
  import "fmt"
  import "time"
  import "runtime"

  //export callOnMeGo
  func callOnMeGo(in C.int, msg *C.char) C.int {
    fmt.Printf("Go.callOnMeGo(): called with arg = %d %s\n", in, C.GoString(msg))
    return in + 1
  }

  func main() {
    timeout := make(chan bool, 2)
    data_chan := make(chan int, 50)
    runtime.GOMAXPROCS(4)
    go func() {
      fmt.Println("go sleep")
      for i := 0; i < 100; i++ {
        data_chan <- i
      }
      C.do_test_so_func(20, 30, (C.callback_fcn)(C.callOnMeGo))

      fmt.Println("20 * 30 =")
      time.Sleep(3 * time.Second)
      fmt.Println("woken")
      timeout <- true
      for i := 0; i < 10; i++ {
        timeout <- true
      }
    }()

    for i := 0; i < 10; i++ {
      go func(i int) {
        for {
          select {
          case v := <-data_chan:
            fmt.Println("child", i, "got", v)
          case <-timeout:
            fmt.Println("child", i, "timeout")
            goto exit
          }
        }
      exit:
        fmt.Println("exit")
      }(i)
    }

    select {
    case <-timeout:
      fmt.Println("main timeout")
    }
    fmt.Println("hello world")
    time.Sleep(10 * time.Second)
  }



category: blog
